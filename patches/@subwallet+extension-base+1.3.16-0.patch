diff --git a/node_modules/@subwallet/extension-base/services/swap-service/handler/chainflip-handler.js b/node_modules/@subwallet/extension-base/services/swap-service/handler/chainflip-handler.js
index d28a90a..397599a 100644
--- a/node_modules/@subwallet/extension-base/services/swap-service/handler/chainflip-handler.js
+++ b/node_modules/@subwallet/extension-base/services/swap-service/handler/chainflip-handler.js
@@ -1,437 +1,22 @@
 // Copyright 2019-2022 @subwallet/extension-base
 // SPDX-License-Identifier: Apache-2.0
 
-import { SwapSDK } from '@chainflip/sdk/swap';
-import { COMMON_ASSETS } from '@subwallet/chain-list';
-import { SwapError } from '@subwallet/extension-base/background/errors/SwapError';
-import { TransactionError } from '@subwallet/extension-base/background/errors/TransactionError';
-import { ChainType, ExtrinsicType } from '@subwallet/extension-base/background/KoniTypes';
-import { _getChainflipEarlyValidationError } from '@subwallet/extension-base/core/logic-validation/swap';
-import { getERC20TransactionObject, getEVMTransactionObject } from '@subwallet/extension-base/services/balance-service/transfer/smart-contract';
-import { createTransferExtrinsic } from '@subwallet/extension-base/services/balance-service/transfer/token';
-import { _getAssetDecimals, _getAssetSymbol, _getChainNativeTokenSlug, _getContractAddressOfToken, _isChainSubstrateCompatible, _isNativeToken, _isSmartContractToken } from '@subwallet/extension-base/services/chain-service/utils';
-import { SwapBaseHandler } from '@subwallet/extension-base/services/swap-service/handler/base-handler';
-import { calculateSwapRate, CHAIN_FLIP_SUPPORTED_MAINNET_ASSET_MAPPING, CHAIN_FLIP_SUPPORTED_MAINNET_MAPPING, CHAIN_FLIP_SUPPORTED_TESTNET_ASSET_MAPPING, CHAIN_FLIP_SUPPORTED_TESTNET_MAPPING, getChainflipOptions, SWAP_QUOTE_TIMEOUT_MAP } from '@subwallet/extension-base/services/swap-service/utils';
-import { BasicTxErrorType } from '@subwallet/extension-base/types';
-import { CommonStepType } from '@subwallet/extension-base/types/service-base';
-import { SwapErrorType, SwapFeeType, SwapProviderId, SwapStepType } from '@subwallet/extension-base/types/swap';
-import BigNumber from 'bignumber.js';
-var ChainflipFeeType;
-(function (ChainflipFeeType) {
-  ChainflipFeeType["INGRESS"] = "INGRESS";
-  ChainflipFeeType["NETWORK"] = "NETWORK";
-  ChainflipFeeType["EGRESS"] = "EGRESS";
-  ChainflipFeeType["BOOST"] = "BOOST";
-  ChainflipFeeType["BROKER"] = "BROKER";
-})(ChainflipFeeType || (ChainflipFeeType = {}));
-const INTERMEDIARY_MAINNET_ASSET_SLUG = COMMON_ASSETS.USDC_ETHEREUM;
-const INTERMEDIARY_TESTNET_ASSET_SLUG = COMMON_ASSETS.USDC_SEPOLIA;
+import { SwapProviderId } from '@subwallet/extension-base/types';
 export const CHAINFLIP_BROKER_API = process.env.CHAINFLIP_BROKER_API || '';
-var CHAINFLIP_QUOTE_ERROR;
-(function (CHAINFLIP_QUOTE_ERROR) {
-  CHAINFLIP_QUOTE_ERROR["InsufficientLiquidity"] = "InsufficientLiquidity";
-  CHAINFLIP_QUOTE_ERROR["InsufficientEgress"] = "is lower than minimum egress amount";
-  CHAINFLIP_QUOTE_ERROR["InsufficientIngress"] = "amount is lower than estimated ingress fee";
-})(CHAINFLIP_QUOTE_ERROR || (CHAINFLIP_QUOTE_ERROR = {}));
 export class ChainflipSwapHandler {
   constructor(chainService, balanceService, isTestnet = true) {
-    this.swapBaseHandler = new SwapBaseHandler({
-      chainService,
-      balanceService,
-      providerName: isTestnet ? 'Chainflip Testnet' : 'Chainflip',
-      providerSlug: isTestnet ? SwapProviderId.CHAIN_FLIP_TESTNET : SwapProviderId.CHAIN_FLIP_MAINNET
-    });
-    this.isTestnet = isTestnet;
     this.providerSlug = isTestnet ? SwapProviderId.CHAIN_FLIP_TESTNET : SwapProviderId.CHAIN_FLIP_MAINNET;
-
-    // @ts-ignore
-    this.swapSdk = new SwapSDK(getChainflipOptions(isTestnet));
-  }
-  get chainService() {
-    return this.swapBaseHandler.chainService;
-  }
-  get balanceService() {
-    return this.swapBaseHandler.balanceService;
-  }
-  get providerInfo() {
-    return this.swapBaseHandler.providerInfo;
-  }
-  get name() {
-    return this.swapBaseHandler.name;
   }
-  get slug() {
-    return this.swapBaseHandler.slug;
-  }
-  get assetMapping() {
-    if (this.isTestnet) {
-      return CHAIN_FLIP_SUPPORTED_TESTNET_ASSET_MAPPING;
-    } else {
-      return CHAIN_FLIP_SUPPORTED_MAINNET_ASSET_MAPPING;
-    }
-  }
-  get chainMapping() {
-    if (this.isTestnet) {
-      return CHAIN_FLIP_SUPPORTED_TESTNET_MAPPING;
-    } else {
-      return CHAIN_FLIP_SUPPORTED_MAINNET_MAPPING;
-    }
-  }
-  get intermediaryAssetSlug() {
-    if (this.isTestnet) {
-      return INTERMEDIARY_TESTNET_ASSET_SLUG;
-    } else {
-      return INTERMEDIARY_MAINNET_ASSET_SLUG;
-    }
-  }
-  async validateSwapRequest(request) {
-    try {
-      // todo: risk of matching wrong chain, asset can lead to loss of funds
-
-      const fromAsset = this.chainService.getAssetBySlug(request.pair.from);
-      const toAsset = this.chainService.getAssetBySlug(request.pair.to);
-      const srcChain = fromAsset.originChain;
-      const destChain = toAsset.originChain;
-      const isSwapCrossChain = srcChain !== destChain;
-      const srcChainInfo = this.chainService.getChainInfoByKey(srcChain);
-      const srcChainId = this.chainMapping[srcChain];
-      const destChainId = this.chainMapping[destChain];
-      const fromAssetId = _getAssetSymbol(fromAsset);
-      const toAssetId = _getAssetSymbol(toAsset);
-      if (!srcChainId || !destChainId || !fromAssetId || !toAssetId) {
-        return {
-          error: SwapErrorType.ASSET_NOT_SUPPORTED
-        };
-      }
-      const [supportedDestChains, srcAssets, destAssets] = await Promise.all([this.swapSdk.getChains(srcChainId), this.swapSdk.getAssets(srcChainId), this.swapSdk.getAssets(destChainId)]);
-      const supportedDestChainId = supportedDestChains.find(c => c.chain === destChainId);
-      const srcAssetData = srcAssets.find(a => {
-        if (_isSmartContractToken(fromAsset)) {
-          var _a$contractAddress;
-          return (a === null || a === void 0 ? void 0 : (_a$contractAddress = a.contractAddress) === null || _a$contractAddress === void 0 ? void 0 : _a$contractAddress.toLowerCase()) === _getContractAddressOfToken(fromAsset).toLowerCase() && a.asset === fromAssetId;
-        }
-        return a.asset === fromAssetId;
-      });
-      const destAssetData = destAssets.find(a => {
-        if (_isSmartContractToken(toAsset)) {
-          var _a$contractAddress2;
-          return (a === null || a === void 0 ? void 0 : (_a$contractAddress2 = a.contractAddress) === null || _a$contractAddress2 === void 0 ? void 0 : _a$contractAddress2.toLowerCase()) === _getContractAddressOfToken(toAsset).toLowerCase() && a.asset === toAssetId;
-        }
-        return a.asset === toAssetId;
-      });
-      if (!destAssetData || !srcAssetData || isSwapCrossChain && !supportedDestChainId) {
-        return {
-          error: SwapErrorType.UNKNOWN
-        };
-      }
-      const bnAmount = new BigNumber(request.fromAmount);
-      const bnMinSwap = new BigNumber(srcAssetData.minimumSwapAmount);
-      if (srcAssetData.maximumSwapAmount) {
-        const bnMaxProtocolSwap = new BigNumber(srcAssetData.maximumSwapAmount);
-        if (bnMinSwap.gte(bnMaxProtocolSwap)) {
-          return {
-            error: SwapErrorType.UNKNOWN
-          };
-        }
-        if (bnAmount.gte(bnMaxProtocolSwap)) {
-          return {
-            error: SwapErrorType.SWAP_EXCEED_ALLOWANCE,
-            metadata: {
-              minSwap: {
-                value: srcAssetData.minimumSwapAmount,
-                decimals: _getAssetDecimals(fromAsset),
-                symbol: fromAsset.symbol
-              },
-              maxSwap: {
-                value: bnMaxProtocolSwap.toString(),
-                decimals: _getAssetDecimals(fromAsset),
-                symbol: fromAsset.symbol
-              },
-              chain: srcChainInfo
-            }
-          };
-        }
-      }
-      if (bnAmount.lt(bnMinSwap)) {
-        // might miss case when minSwap is 0
-        return {
-          error: SwapErrorType.NOT_MEET_MIN_SWAP,
-          metadata: {
-            minSwap: {
-              value: srcAssetData.minimumSwapAmount,
-              decimals: _getAssetDecimals(fromAsset),
-              symbol: fromAsset.symbol
-            },
-            maxSwap: {
-              value: srcAssetData.maximumSwapAmount,
-              decimals: _getAssetDecimals(fromAsset),
-              symbol: fromAsset.symbol
-            },
-            chain: srcChainInfo
-          }
-        };
-      }
-      return {
-        metadata: {
-          minSwap: {
-            value: srcAssetData.minimumSwapAmount,
-            decimals: _getAssetDecimals(fromAsset),
-            symbol: fromAsset.symbol
-          },
-          maxSwap: {
-            value: srcAssetData.maximumSwapAmount,
-            decimals: _getAssetDecimals(fromAsset),
-            symbol: fromAsset.symbol
-          },
-          chain: srcChainInfo
-        }
-      };
-    } catch (e) {
-      return {
-        error: SwapErrorType.UNKNOWN
-      };
-    }
-  }
-  parseSwapPath(fromAsset, toAsset) {
-    if (toAsset.slug !== this.intermediaryAssetSlug && fromAsset.slug !== this.intermediaryAssetSlug) {
-      // Chainflip always use USDC as intermediary
-      return [fromAsset.slug, this.intermediaryAssetSlug, toAsset.slug]; // todo: generalize this
-    }
-
-    return [fromAsset.slug, toAsset.slug];
-  }
-  async getSwapQuote(request) {
-    const fromAsset = this.chainService.getAssetBySlug(request.pair.from);
-    const toAsset = this.chainService.getAssetBySlug(request.pair.to);
-    const fromChain = this.chainService.getChainInfoByKey(fromAsset.originChain);
-    const fromChainNativeTokenSlug = _getChainNativeTokenSlug(fromChain);
-    if (!fromAsset || !toAsset) {
-      return new SwapError(SwapErrorType.UNKNOWN);
-    }
-    const earlyValidation = await this.validateSwapRequest(request);
-    const metadata = earlyValidation.metadata;
-    if (earlyValidation.error) {
-      return _getChainflipEarlyValidationError(earlyValidation.error, metadata);
-    }
-    const srcChainId = this.chainMapping[fromAsset.originChain];
-    const destChainId = this.chainMapping[toAsset.originChain];
-    const fromAssetId = _getAssetSymbol(fromAsset);
-    const toAssetId = _getAssetSymbol(toAsset);
-    try {
-      var _metadata$maxSwap;
-      const quoteResponse = await this.swapSdk.getQuote({
-        srcChain: srcChainId,
-        destChain: destChainId,
-        srcAsset: fromAssetId,
-        destAsset: toAssetId,
-        amount: request.fromAmount
-      });
-      const feeComponent = [];
-      quoteResponse.quote.includedFees.forEach(fee => {
-        switch (fee.type) {
-          case ChainflipFeeType.INGRESS:
-            {
-              feeComponent.push({
-                tokenSlug: fromAsset.slug,
-                amount: fee.amount,
-                feeType: SwapFeeType.NETWORK_FEE
-              });
-              break;
-            }
-
-          // eslint-disable-next-line no-fallthrough
-          case ChainflipFeeType.EGRESS:
-            {
-              feeComponent.push({
-                tokenSlug: toAsset.slug,
-                amount: fee.amount,
-                feeType: SwapFeeType.NETWORK_FEE
-              });
-              break;
-            }
-          case ChainflipFeeType.NETWORK:
-
-          // eslint-disable-next-line no-fallthrough
-          case ChainflipFeeType.BOOST:
-
-          // eslint-disable-next-line no-fallthrough
-          case ChainflipFeeType.BROKER:
-            {
-              feeComponent.push({
-                tokenSlug: this.intermediaryAssetSlug,
-                amount: fee.amount,
-                feeType: SwapFeeType.PLATFORM_FEE
-              });
-              break;
-            }
-        }
-      });
-      const defaultFeeToken = _isNativeToken(fromAsset) ? fromAsset.slug : fromChainNativeTokenSlug;
-      return {
-        pair: request.pair,
-        fromAmount: request.fromAmount,
-        toAmount: quoteResponse.quote.egressAmount.toString(),
-        rate: calculateSwapRate(request.fromAmount, quoteResponse.quote.egressAmount.toString(), fromAsset, toAsset),
-        provider: this.providerInfo,
-        aliveUntil: +Date.now() + (SWAP_QUOTE_TIMEOUT_MAP[this.slug] || SWAP_QUOTE_TIMEOUT_MAP.default),
-        minSwap: metadata.minSwap.value,
-        maxSwap: (_metadata$maxSwap = metadata.maxSwap) === null || _metadata$maxSwap === void 0 ? void 0 : _metadata$maxSwap.value,
-        estimatedArrivalTime: quoteResponse.quote.estimatedDurationSeconds,
-        // in seconds
-        isLowLiquidity: quoteResponse.quote.lowLiquidityWarning,
-        feeInfo: {
-          feeComponent: feeComponent,
-          defaultFeeToken,
-          feeOptions: [defaultFeeToken]
-        },
-        route: {
-          path: this.parseSwapPath(fromAsset, toAsset)
-        }
-      };
-    } catch (e) {
-      var _error$response;
-      const error = e;
-      const errorObj = error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data;
-      if (errorObj && errorObj.error && errorObj.error.includes(CHAINFLIP_QUOTE_ERROR.InsufficientLiquidity)) {
-        // todo: Chainflip will improve this
-        return new SwapError(SwapErrorType.NOT_ENOUGH_LIQUIDITY);
-      }
-      if (errorObj && errorObj.message && errorObj.message.includes(CHAINFLIP_QUOTE_ERROR.InsufficientLiquidity)) {
-        return new SwapError(SwapErrorType.NOT_ENOUGH_LIQUIDITY);
-      }
-      return new SwapError(SwapErrorType.ERROR_FETCHING_QUOTE);
-    }
-  }
-  async validateSwapProcess(params) {
-    const amount = params.selectedQuote.fromAmount;
-    const bnAmount = new BigNumber(amount);
-    if (bnAmount.lte(0)) {
-      return [new TransactionError(BasicTxErrorType.INVALID_PARAMS, 'Amount must be greater than 0')];
-    }
-    let isXcmOk = false;
-    for (const [index, step] of params.process.steps.entries()) {
-      const getErrors = async () => {
-        switch (step.type) {
-          case CommonStepType.DEFAULT:
-            return Promise.resolve([]);
-          case CommonStepType.TOKEN_APPROVAL:
-            return Promise.reject(new TransactionError(BasicTxErrorType.UNSUPPORTED));
-          default:
-            return this.swapBaseHandler.validateSwapStep(params, isXcmOk, index);
-        }
-      };
-      const errors = await getErrors();
-      if (errors.length) {
-        return errors;
-      } else if (step.type === CommonStepType.XCM) {
-        isXcmOk = true;
-      }
-    }
-    return [];
-  }
-  async handleSubmitStep(params) {
-    const {
-      address,
-      quote,
-      recipient,
-      slippage
-    } = params;
-    const pair = quote.pair;
-    const fromAsset = this.chainService.getAssetBySlug(pair.from);
-    const toAsset = this.chainService.getAssetBySlug(pair.to);
-    const chainInfo = this.chainService.getChainInfoByKey(fromAsset.originChain);
-    const chainType = _isChainSubstrateCompatible(chainInfo) ? ChainType.SUBSTRATE : ChainType.EVM;
-    const receiver = recipient !== null && recipient !== void 0 ? recipient : address;
-    const srcChainId = this.chainMapping[fromAsset.originChain];
-    const destChainId = this.chainMapping[toAsset.originChain];
-    const fromAssetId = _getAssetSymbol(fromAsset);
-    const toAssetId = _getAssetSymbol(toAsset);
-    const minReceive = new BigNumber(quote.rate).times(1 - slippage).toString();
-    const depositAddressResponse = await this.swapSdk.requestDepositAddress({
-      srcChain: srcChainId,
-      destChain: destChainId,
-      srcAsset: fromAssetId,
-      destAsset: toAssetId,
-      destAddress: receiver,
-      amount: quote.fromAmount,
-      fillOrKillParams: {
-        minPrice: minReceive,
-        // minimum accepted price for swaps through the channel
-        refundAddress: address,
-        // address to which assets are refunded
-        retryDurationBlocks: 100 // 100 blocks * 6 seconds = 10 minutes before deposits are refunded
-      }
-    });
-
-    const txData = {
-      address,
-      provider: this.providerInfo,
-      quote: params.quote,
-      slippage: params.slippage,
-      recipient,
-      depositChannelId: depositAddressResponse.depositChannelId,
-      depositAddress: depositAddressResponse.depositAddress,
-      process: params.process
-    };
-    let extrinsic;
-    if (chainType === ChainType.SUBSTRATE) {
-      const chainApi = this.chainService.getSubstrateApi(chainInfo.slug);
-      const substrateApi = await chainApi.isReady;
-      const [submittableExtrinsic] = await createTransferExtrinsic({
-        from: address,
-        networkKey: chainInfo.slug,
-        substrateApi,
-        to: depositAddressResponse.depositAddress,
-        tokenInfo: fromAsset,
-        transferAll: false,
-        // always false, because we do not allow swapping all the balance
-        value: quote.fromAmount
-      });
-      extrinsic = submittableExtrinsic;
-    } else {
-      if (_isNativeToken(fromAsset)) {
-        const [transactionConfig] = await getEVMTransactionObject(chainInfo, address, depositAddressResponse.depositAddress, quote.fromAmount, false, this.chainService.getEvmApi(chainInfo.slug));
-        extrinsic = transactionConfig;
-      } else {
-        const [transactionConfig] = await getERC20TransactionObject(_getContractAddressOfToken(fromAsset), chainInfo, address, depositAddressResponse.depositAddress, quote.fromAmount, false, this.chainService.getEvmApi(chainInfo.slug));
-        extrinsic = transactionConfig;
-      }
-    }
-    return {
-      txChain: fromAsset.originChain,
-      txData,
-      extrinsic,
-      transferNativeAmount: _isNativeToken(fromAsset) ? quote.fromAmount : '0',
-      // todo
-      extrinsicType: ExtrinsicType.SWAP,
-      chainType
-    };
+  handleSubmitStep(params) {
+    throw new Error('Not implemented');
   }
-  async handleSwapProcess(params) {
-    const {
-      currentStep,
-      process
-    } = params;
-    const type = process.steps[currentStep].type;
-    switch (type) {
-      case CommonStepType.DEFAULT:
-        return Promise.reject(new TransactionError(BasicTxErrorType.UNSUPPORTED));
-      case SwapStepType.SWAP:
-        return this.handleSubmitStep(params);
-      default:
-        return this.handleSubmitStep(params);
-    }
+  handleSwapProcess(params) {
+    throw new Error('Not implemented');
   }
-  async getSubmitStep(params) {
-    if (params.selectedQuote) {
-      const submitStep = {
-        name: 'Swap',
-        type: SwapStepType.SWAP
-      };
-      return Promise.resolve([submitStep, params.selectedQuote.feeInfo]);
-    }
-    return Promise.resolve(undefined);
+  validateSwapProcess(params) {
+    return Promise.resolve([]);
   }
-  generateOptimalProcess(params) {
-    return this.swapBaseHandler.generateOptimalProcess(params, [this.getSubmitStep]);
+  validateSwapRequest(request) {
+    throw new Error('Not implemented');
   }
 }
\ No newline at end of file
diff --git a/node_modules/@subwallet/extension-base/services/swap-service/utils.js b/node_modules/@subwallet/extension-base/services/swap-service/utils.js
index 7657ca1..c8b3fb5 100644
--- a/node_modules/@subwallet/extension-base/services/swap-service/utils.js
+++ b/node_modules/@subwallet/extension-base/services/swap-service/utils.js
@@ -1,7 +1,6 @@
 // Copyright 2019-2022 @subwallet/extension-base
 // SPDX-License-Identifier: Apache-2.0
 
-import { Assets, Chains } from '@chainflip/sdk/swap';
 import { COMMON_ASSETS, COMMON_CHAIN_SLUGS } from '@subwallet/chain-list';
 import { _getAssetDecimals } from '@subwallet/extension-base/services/chain-service/utils';
 import { CHAINFLIP_BROKER_API } from '@subwallet/extension-base/services/swap-service/handler/chainflip-handler';
@@ -11,24 +10,24 @@ export const CHAIN_FLIP_TESTNET_EXPLORER = 'https://blocks-perseverance.chainfli
 export const CHAIN_FLIP_MAINNET_EXPLORER = 'https://scan.chainflip.io';
 export const SIMPLE_SWAP_EXPLORER = 'https://simpleswap.io';
 export const CHAIN_FLIP_SUPPORTED_MAINNET_MAPPING = {
-  [COMMON_CHAIN_SLUGS.POLKADOT]: Chains.Polkadot,
-  [COMMON_CHAIN_SLUGS.ETHEREUM]: Chains.Ethereum,
-  [COMMON_CHAIN_SLUGS.ARBITRUM]: Chains.Arbitrum
+  [COMMON_CHAIN_SLUGS.POLKADOT]: 'Polkadot',
+  [COMMON_CHAIN_SLUGS.ETHEREUM]: 'Ethereum',
+  [COMMON_CHAIN_SLUGS.ARBITRUM]: 'Arbitrum',
 };
 export const CHAIN_FLIP_SUPPORTED_TESTNET_MAPPING = {
-  [COMMON_CHAIN_SLUGS.ETHEREUM_SEPOLIA]: Chains.Ethereum,
-  [COMMON_CHAIN_SLUGS.CHAINFLIP_POLKADOT]: Chains.Polkadot
+  [COMMON_CHAIN_SLUGS.ETHEREUM_SEPOLIA]: 'Ethereum',
+  [COMMON_CHAIN_SLUGS.CHAINFLIP_POLKADOT]: 'Polkadot',
 };
 export const CHAIN_FLIP_SUPPORTED_MAINNET_ASSET_MAPPING = {
-  [COMMON_ASSETS.DOT]: Assets.DOT,
-  [COMMON_ASSETS.ETH]: Assets.ETH,
-  [COMMON_ASSETS.USDC_ETHEREUM]: Assets.USDC,
-  [COMMON_ASSETS.USDT_ETHEREUM]: Assets.USDT
+  [COMMON_ASSETS.DOT]: 'DOT',
+  [COMMON_ASSETS.ETH]: 'ETH',
+  [COMMON_ASSETS.USDC_ETHEREUM]: 'USDC',
+  [COMMON_ASSETS.USDT_ETHEREUM]: 'USDT'
 };
 export const CHAIN_FLIP_SUPPORTED_TESTNET_ASSET_MAPPING = {
-  [COMMON_ASSETS.PDOT]: Assets.DOT,
-  [COMMON_ASSETS.ETH_SEPOLIA]: Assets.ETH,
-  [COMMON_ASSETS.USDC_SEPOLIA]: Assets.USDC
+  [COMMON_ASSETS.PDOT]: 'DOT',
+  [COMMON_ASSETS.ETH_SEPOLIA]: 'ETH',
+  [COMMON_ASSETS.USDC_SEPOLIA]: 'USDC'
 };
 export const SIMPLE_SWAP_SUPPORTED_TESTNET_ASSET_MAPPING = {
   'bittensor-NATIVE-TAO': 'tao',
