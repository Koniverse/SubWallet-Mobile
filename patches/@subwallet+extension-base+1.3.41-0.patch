diff --git a/node_modules/@subwallet/extension-base/cjs/services/balance-service/helpers/subscribe/cardano/utils.js b/node_modules/@subwallet/extension-base/cjs/services/balance-service/helpers/subscribe/cardano/utils.js
index 5a7d4ba..1b7340f 100644
--- a/node_modules/@subwallet/extension-base/cjs/services/balance-service/helpers/subscribe/cardano/utils.js
+++ b/node_modules/@subwallet/extension-base/cjs/services/balance-service/helpers/subscribe/cardano/utils.js
@@ -9,7 +9,7 @@ exports.getCardanoAssetId = getCardanoAssetId;
 exports.getCardanoTxFee = getCardanoTxFee;
 exports.retryCardanoTxStatus = retryCardanoTxStatus;
 exports.splitCardanoId = splitCardanoId;
-var _cardanoSerializationLibNodejs = require("@emurgo/cardano-serialization-lib-nodejs");
+var _cardanoSerializationLibNodejs = require("@emurgo/csl-mobile-bridge");
 // Copyright 2019-2022 @subwallet/extension-base
 // SPDX-License-Identifier: Apache-2.0
 
diff --git a/node_modules/@subwallet/extension-base/cjs/services/balance-service/transfer/cardano-transfer.js b/node_modules/@subwallet/extension-base/cjs/services/balance-service/transfer/cardano-transfer.js
index d7880a3..f71899e 100644
--- a/node_modules/@subwallet/extension-base/cjs/services/balance-service/transfer/cardano-transfer.js
+++ b/node_modules/@subwallet/extension-base/cjs/services/balance-service/transfer/cardano-transfer.js
@@ -4,7 +4,7 @@ Object.defineProperty(exports, "__esModule", {
   value: true
 });
 exports.createCardanoTransaction = createCardanoTransaction;
-var csl = _interopRequireWildcard(require("@emurgo/cardano-serialization-lib-nodejs"));
+var csl = _interopRequireWildcard(require("@emurgo/csl-mobile-bridge"));
 var _types = require("@subwallet/chain-list/types");
 var _utils = require("@subwallet/extension-base/services/balance-service/helpers/subscribe/cardano/utils");
 var _subwalletApiSdk = require("@subwallet/subwallet-api-sdk");
diff --git a/node_modules/@subwallet/extension-base/cjs/services/earning-service/constants/chains.js b/node_modules/@subwallet/extension-base/cjs/services/earning-service/constants/chains.js
index 70b6ddc..1fcbda5 100644
--- a/node_modules/@subwallet/extension-base/cjs/services/earning-service/constants/chains.js
+++ b/node_modules/@subwallet/extension-base/cjs/services/earning-service/constants/chains.js
@@ -24,6 +24,7 @@ const _STAKING_CHAIN_GROUP = {
   krest_network: ['krest_network'],
   manta: ['manta_network'],
   bittensor: ['bittensor', 'bittensor_testnet'],
+  energy: ['energy_web_x_testnet', 'energy_web_x'],
   mythos: ['mythos', 'muse_testnet']
 };
 exports._STAKING_CHAIN_GROUP = _STAKING_CHAIN_GROUP;
diff --git a/node_modules/@subwallet/extension-base/cjs/services/earning-service/utils/index.js b/node_modules/@subwallet/extension-base/cjs/services/earning-service/utils/index.js
index 7ac33d0..a75f6b2 100644
--- a/node_modules/@subwallet/extension-base/cjs/services/earning-service/utils/index.js
+++ b/node_modules/@subwallet/extension-base/cjs/services/earning-service/utils/index.js
@@ -120,6 +120,8 @@ function isActionFromValidator(stakingType, chain) {
     return true;
   } else if (_constants._STAKING_CHAIN_GROUP.mythos.includes(chain)) {
     return true;
+  } else if (_constants._STAKING_CHAIN_GROUP.energy.includes(chain)) {
+    return true;
   }
   return false;
 }
diff --git a/node_modules/@subwallet/extension-base/core/utils.js b/node_modules/@subwallet/extension-base/core/utils.js
index 92f858b..11d3118 100644
--- a/node_modules/@subwallet/extension-base/core/utils.js
+++ b/node_modules/@subwallet/extension-base/core/utils.js
@@ -56,7 +56,7 @@ export function _isValidAddressForEcosystem(validateRecipientParams) {
   } = validateRecipientParams;
   if (!isAddressAndChainCompatible(toAddress, destChainInfo)) {
     if (_isChainEvmCompatible(destChainInfo) || _isChainSubstrateCompatible(destChainInfo) || _isChainTonCompatible(destChainInfo) || _isChainCardanoCompatible(destChainInfo)) {
-      return 'Recipient address must be the same type as sender address';
+      return `Recipient address must be a valid ${destChainInfo.name} address`;
     }
     return 'Unknown chain type';
   }
@@ -69,8 +69,8 @@ export function _isValidSubstrateAddressFormat(validateRecipientParams) {
     toAddress
   } = validateRecipientParams;
   const addressPrefix = (_destChainInfo$substr = destChainInfo === null || destChainInfo === void 0 ? void 0 : (_destChainInfo$substr2 = destChainInfo.substrateInfo) === null || _destChainInfo$substr2 === void 0 ? void 0 : _destChainInfo$substr2.addressPrefix) !== null && _destChainInfo$substr !== void 0 ? _destChainInfo$substr : 42;
-  const toAddressFormatted = reformatAddress(toAddress, addressPrefix);
-  if (toAddressFormatted !== toAddress) {
+  const toAddressFormatted = reformatAddress(toAddress, addressPrefix, undefined, false);
+  if (toAddressFormatted && toAddressFormatted !== toAddress) {
     return `Recipient address must be a valid ${destChainInfo.name} address`;
   }
   return '';
diff --git a/node_modules/@subwallet/extension-base/services/balance-service/helpers/subscribe/cardano/utils.js b/node_modules/@subwallet/extension-base/services/balance-service/helpers/subscribe/cardano/utils.js
index 26a5f26..a3fab9d 100644
--- a/node_modules/@subwallet/extension-base/services/balance-service/helpers/subscribe/cardano/utils.js
+++ b/node_modules/@subwallet/extension-base/services/balance-service/helpers/subscribe/cardano/utils.js
@@ -1,7 +1,7 @@
 // Copyright 2019-2022 @subwallet/extension-base
 // SPDX-License-Identifier: Apache-2.0
 
-import { Transaction } from '@emurgo/cardano-serialization-lib-nodejs';
+import { Transaction } from '@emurgo/csl-mobile-bridge';
 export function getCardanoAssetId(chainAsset) {
   var _chainAsset$metadata;
   return (_chainAsset$metadata = chainAsset.metadata) === null || _chainAsset$metadata === void 0 ? void 0 : _chainAsset$metadata.cardanoId;
diff --git a/node_modules/@subwallet/extension-base/services/balance-service/transfer/cardano-transfer.js b/node_modules/@subwallet/extension-base/services/balance-service/transfer/cardano-transfer.js
index 8f32cf5..ca269f7 100644
--- a/node_modules/@subwallet/extension-base/services/balance-service/transfer/cardano-transfer.js
+++ b/node_modules/@subwallet/extension-base/services/balance-service/transfer/cardano-transfer.js
@@ -1,7 +1,7 @@
 // Copyright 2019-2022 @subwallet/extension-base
 // SPDX-License-Identifier: Apache-2.0
 
-import * as csl from '@emurgo/cardano-serialization-lib-nodejs';
+import * as csl from '@emurgo/csl-mobile-bridge';
 import { _AssetType } from '@subwallet/chain-list/types';
 import { getAdaBelongUtxo, getCardanoTxFee, splitCardanoId } from '@subwallet/extension-base/services/balance-service/helpers/subscribe/cardano/utils';
 import { subwalletApiSdk } from '@subwallet/subwallet-api-sdk';
diff --git a/node_modules/@subwallet/extension-base/services/earning-service/constants/chains.js b/node_modules/@subwallet/extension-base/services/earning-service/constants/chains.js
index 320772f..34512ff 100644
--- a/node_modules/@subwallet/extension-base/services/earning-service/constants/chains.js
+++ b/node_modules/@subwallet/extension-base/services/earning-service/constants/chains.js
@@ -18,6 +18,7 @@ export const _STAKING_CHAIN_GROUP = {
   krest_network: ['krest_network'],
   manta: ['manta_network'],
   bittensor: ['bittensor', 'bittensor_testnet'],
+  energy: ['energy_web_x_testnet', 'energy_web_x'],
   mythos: ['mythos', 'muse_testnet']
 };
 export const TON_CHAINS = ['ton', 'ton_testnet'];
diff --git a/node_modules/@subwallet/extension-base/services/earning-service/utils/index.js b/node_modules/@subwallet/extension-base/services/earning-service/utils/index.js
index c4c4805..09a9aaa 100644
--- a/node_modules/@subwallet/extension-base/services/earning-service/utils/index.js
+++ b/node_modules/@subwallet/extension-base/services/earning-service/utils/index.js
@@ -93,10 +93,11 @@ export async function parseIdentity(substrateApi, address, children) {
   }
   return [undefined, false];
 }
-export function isActionFromValidator(stakingType, chain) {
+export function isActionFromValidator (stakingType: YieldPoolType, chain: string) {
   if (stakingType === YieldPoolType.NOMINATION_POOL || stakingType === YieldPoolType.LIQUID_STAKING || stakingType === YieldPoolType.LENDING) {
     return false;
   }
+
   if (_STAKING_CHAIN_GROUP.astar.includes(chain)) {
     return true;
   } else if (_STAKING_CHAIN_GROUP.amplitude.includes(chain)) {
@@ -107,7 +108,10 @@ export function isActionFromValidator(stakingType, chain) {
     return true;
   } else if (_STAKING_CHAIN_GROUP.mythos.includes(chain)) {
     return true;
+  } else if (_STAKING_CHAIN_GROUP.energy.includes(chain)) {
+    return true;
   }
+
   return false;
 }
 export const isNominationPool = pool => {
diff --git a/node_modules/@subwallet/extension-base/services/swap-service/handler/chainflip-handler.js b/node_modules/@subwallet/extension-base/services/swap-service/handler/chainflip-handler.js
index 82e18b1..397599a 100644
--- a/node_modules/@subwallet/extension-base/services/swap-service/handler/chainflip-handler.js
+++ b/node_modules/@subwallet/extension-base/services/swap-service/handler/chainflip-handler.js
@@ -1,263 +1,22 @@
 // Copyright 2019-2022 @subwallet/extension-base
 // SPDX-License-Identifier: Apache-2.0
 
-import { COMMON_ASSETS } from '@subwallet/chain-list';
-import { TransactionError } from '@subwallet/extension-base/background/errors/TransactionError';
-import { ChainType, ExtrinsicType } from '@subwallet/extension-base/background/KoniTypes';
-import { getERC20TransactionObject, getEVMTransactionObject } from '@subwallet/extension-base/services/balance-service/transfer/smart-contract';
-import { createSubstrateExtrinsic } from '@subwallet/extension-base/services/balance-service/transfer/token';
-import { _getAssetSymbol, _getContractAddressOfToken, _isChainSubstrateCompatible, _isNativeToken } from '@subwallet/extension-base/services/chain-service/utils';
-import { SwapBaseHandler } from '@subwallet/extension-base/services/swap-service/handler/base-handler';
-import { BasicTxErrorType, CommonStepType, DynamicSwapType, SwapProviderId, SwapStepType } from '@subwallet/extension-base/types';
-import { ProxyServiceRoute } from '@subwallet/extension-base/types/environment';
-import { _reformatAddressWithChain, fetchFromProxyService } from '@subwallet/extension-base/utils';
-import { getId } from '@subwallet/extension-base/utils/getId';
-import BigNumber from 'bignumber.js';
-const INTERMEDIARY_MAINNET_ASSET_SLUG = COMMON_ASSETS.USDC_ETHEREUM;
-const INTERMEDIARY_TESTNET_ASSET_SLUG = COMMON_ASSETS.USDC_SEPOLIA;
+import { SwapProviderId } from '@subwallet/extension-base/types';
+export const CHAINFLIP_BROKER_API = process.env.CHAINFLIP_BROKER_API || '';
 export class ChainflipSwapHandler {
-  // private baseUrl: string;
-  // private assetsUrl: string;
-
-  constructor(chainService, balanceService, feeService, isTestnet = true) {
-    this.swapBaseHandler = new SwapBaseHandler({
-      chainService,
-      balanceService,
-      feeService,
-      providerName: isTestnet ? 'Chainflip Testnet' : 'Chainflip',
-      providerSlug: isTestnet ? SwapProviderId.CHAIN_FLIP_TESTNET : SwapProviderId.CHAIN_FLIP_MAINNET
-    });
-    this.isTestnet = isTestnet;
+  constructor(chainService, balanceService, isTestnet = true) {
     this.providerSlug = isTestnet ? SwapProviderId.CHAIN_FLIP_TESTNET : SwapProviderId.CHAIN_FLIP_MAINNET;
-    // this.baseUrl = getChainflipSwap(isTestnet);
-    // this.assetsUrl = getAssetsUrl(isTestnet);
-  }
-
-  get chainService() {
-    return this.swapBaseHandler.chainService;
-  }
-  get balanceService() {
-    return this.swapBaseHandler.balanceService;
   }
-  get providerInfo() {
-    return this.swapBaseHandler.providerInfo;
+  handleSubmitStep(params) {
+    throw new Error('Not implemented');
   }
-  get name() {
-    return this.swapBaseHandler.name;
+  handleSwapProcess(params) {
+    throw new Error('Not implemented');
   }
-  get slug() {
-    return this.swapBaseHandler.slug;
-  }
-  get intermediaryAssetSlug() {
-    if (this.isTestnet) {
-      return INTERMEDIARY_TESTNET_ASSET_SLUG;
-    } else {
-      return INTERMEDIARY_MAINNET_ASSET_SLUG;
-    }
-  }
-  async handleSubmitStep(params) {
-    const {
-      address,
-      quote,
-      recipient,
-      slippage
-    } = params;
-    const pair = quote.pair;
-    const fromAsset = this.chainService.getAssetBySlug(pair.from);
-    const toAsset = this.chainService.getAssetBySlug(pair.to);
-    const chainInfo = this.chainService.getChainInfoByKey(fromAsset.originChain);
-    const toChainInfo = this.chainService.getChainInfoByKey(fromAsset.originChain);
-    const chainType = _isChainSubstrateCompatible(chainInfo) ? ChainType.SUBSTRATE : ChainType.EVM;
-    const receiver = _reformatAddressWithChain(recipient !== null && recipient !== void 0 ? recipient : address, toChainInfo);
-    const fromAssetId = _getAssetSymbol(fromAsset);
-    const toAssetId = _getAssetSymbol(toAsset);
-    const minReceive = new BigNumber(quote.rate).times(1 - slippage).toString();
-    const processMetadata = params.process.steps[params.currentStep].metadata;
-    const quoteMetadata = processMetadata;
-    if (!processMetadata || !quoteMetadata) {
-      throw new Error('Metadata for Chainflip not found');
-    }
-    if (processMetadata.destChain !== quoteMetadata.destChain || processMetadata.srcChain !== quoteMetadata.srcChain) {
-      throw new Error('Metadata for Chainflip not found');
-    }
-    const assetsResponse = await fetchFromProxyService(ProxyServiceRoute.CHAINFLIP, '/assets', {
-      method: 'GET'
-    }, this.isTestnet);
-    const _allAssets = await assetsResponse.json();
-    const allAssets = _allAssets.assets;
-    const sourceAsset = allAssets.find(asset => asset.network === processMetadata.srcChain && asset.ticker === fromAssetId);
-    const destinationAsset = allAssets.find(asset => asset.network === processMetadata.destChain && asset.ticker === toAssetId);
-    if (!sourceAsset || !destinationAsset) {
-      throw new Error('Error get Chainflip data');
-    }
-    const depositParams = {
-      destinationAddress: receiver,
-      destinationAsset: destinationAsset.id,
-      sourceAsset: sourceAsset.id,
-      minimumPrice: minReceive,
-      // minimum accepted price for swaps through the channel
-      refundAddress: address,
-      // address to which assets are refunded
-      retryDurationInBlocks: '100' // 100 blocks * 6 seconds = 10 minutes before deposits are refunded
-    };
-
-    const path = `/swap?${new URLSearchParams(depositParams).toString()}`;
-    const response = await fetchFromProxyService(ProxyServiceRoute.CHAINFLIP, path, {
-      method: 'GET'
-    }, this.isTestnet);
-    const data = await response.json();
-    if (!data.id || !data.address || data.address === '' || !data.issuedBlock || !data.network || !data.channelId) {
-      throw new Error('Error get Chainflip data');
-    }
-    const depositChannelId = `${data.issuedBlock}-${data.network}-${data.channelId}`;
-    const depositAddress = data.address;
-    const txData = {
-      address,
-      provider: this.providerInfo,
-      quote: params.quote,
-      slippage: params.slippage,
-      recipient,
-      depositChannelId: depositChannelId,
-      depositAddress: depositAddress,
-      process: params.process
-    };
-    let extrinsic;
-    if (chainType === ChainType.SUBSTRATE) {
-      const chainApi = this.chainService.getSubstrateApi(chainInfo.slug);
-      const substrateApi = await chainApi.isReady;
-      const [submittableExtrinsic] = await createSubstrateExtrinsic({
-        from: address,
-        networkKey: chainInfo.slug,
-        substrateApi,
-        to: depositAddress,
-        tokenInfo: fromAsset,
-        transferAll: false,
-        // always false, because we do not allow swapping all the balance
-        value: quote.fromAmount
-      });
-      extrinsic = submittableExtrinsic;
-    } else {
-      const id = getId();
-      const feeInfo = await this.swapBaseHandler.feeService.subscribeChainFee(id, chainInfo.slug, 'evm');
-      if (_isNativeToken(fromAsset)) {
-        const [transactionConfig] = await getEVMTransactionObject({
-          chain: chainInfo.slug,
-          evmApi: this.chainService.getEvmApi(chainInfo.slug),
-          from: address,
-          to: depositAddress,
-          value: quote.fromAmount,
-          feeInfo,
-          transferAll: false
-        });
-        extrinsic = transactionConfig;
-      } else {
-        const [transactionConfig] = await getERC20TransactionObject({
-          assetAddress: _getContractAddressOfToken(fromAsset),
-          chain: chainInfo.slug,
-          evmApi: this.chainService.getEvmApi(chainInfo.slug),
-          from: address,
-          to: depositAddress,
-          value: quote.fromAmount,
-          feeInfo,
-          transferAll: false
-        });
-        extrinsic = transactionConfig;
-      }
-    }
-    return {
-      txChain: fromAsset.originChain,
-      txData,
-      extrinsic,
-      transferNativeAmount: _isNativeToken(fromAsset) ? quote.fromAmount : '0',
-      // todo
-      extrinsicType: ExtrinsicType.SWAP,
-      chainType
-    };
+  validateSwapProcess(params) {
+    return Promise.resolve([]);
   }
-  async handleSwapProcess(params) {
-    const {
-      currentStep,
-      process
-    } = params;
-    const type = process.steps[currentStep].type;
-    switch (type) {
-      case CommonStepType.DEFAULT:
-        return Promise.reject(new TransactionError(BasicTxErrorType.UNSUPPORTED));
-      case SwapStepType.SWAP:
-        return this.handleSubmitStep(params);
-      default:
-        return this.handleSubmitStep(params);
-    }
-  }
-  async getSubmitStep(params, stepIndex) {
-    var _params$selectedQuote;
-    const metadata = (_params$selectedQuote = params.selectedQuote) === null || _params$selectedQuote === void 0 ? void 0 : _params$selectedQuote.metadata;
-    if (!params.selectedQuote) {
-      return Promise.resolve(undefined);
-    }
-    if (!metadata || !metadata.srcChain || !metadata.destChain) {
-      return Promise.resolve(undefined);
-    }
-    const originTokenInfo = this.chainService.getAssetBySlug(params.selectedQuote.pair.from);
-    const destinationTokenInfo = this.chainService.getAssetBySlug(params.selectedQuote.pair.to);
-    const originChain = this.chainService.getChainInfoByKey(originTokenInfo.originChain);
-    const destinationChain = this.chainService.getChainInfoByKey(destinationTokenInfo.originChain);
-    const submitStep = {
-      name: 'Swap',
-      type: SwapStepType.SWAP,
-      // @ts-ignore
-      metadata: {
-        sendingValue: params.request.fromAmount.toString(),
-        expectedReceive: params.selectedQuote.toAmount,
-        originTokenInfo,
-        destinationTokenInfo,
-        sender: _reformatAddressWithChain(params.request.address, originChain),
-        receiver: _reformatAddressWithChain(params.request.recipient || params.request.address, destinationChain),
-        srcChain: metadata.srcChain,
-        destChain: metadata.destChain,
-        version: 2
-      }
-    };
-    return Promise.resolve([submitStep, params.selectedQuote.feeInfo]);
-  }
-  generateOptimalProcessV2(params) {
-    return this.swapBaseHandler.generateOptimalProcessV2(params, [this.getSubmitStep.bind(this)]);
-  }
-  async validateSwapProcessV2(params) {
-    // todo: recheck address and recipient format in params
-    const {
-      process,
-      selectedQuote
-    } = params; // todo: review flow, currentStep param.
-
-    // todo: validate path with optimalProcess
-    // todo: review error message in case many step swap
-    if (BigNumber(selectedQuote.fromAmount).lte(0)) {
-      return [new TransactionError(BasicTxErrorType.INVALID_PARAMS, 'Amount must be greater than 0')];
-    }
-    const actionList = JSON.stringify(process.path.map(step => step.action));
-    const swap = actionList === JSON.stringify([DynamicSwapType.SWAP]);
-    const swapXcm = actionList === JSON.stringify([DynamicSwapType.SWAP, DynamicSwapType.BRIDGE]);
-    const xcmSwap = actionList === JSON.stringify([DynamicSwapType.BRIDGE, DynamicSwapType.SWAP]);
-    const xcmSwapXcm = actionList === JSON.stringify([DynamicSwapType.BRIDGE, DynamicSwapType.SWAP, DynamicSwapType.BRIDGE]);
-    const swapIndex = params.process.steps.findIndex(step => step.type === SwapStepType.SWAP); // todo
-
-    if (swapIndex <= -1) {
-      return [new TransactionError(BasicTxErrorType.INTERNAL_ERROR)];
-    }
-    if (swap) {
-      return this.swapBaseHandler.validateSwapOnlyProcess(params, swapIndex); // todo: create interface for input request
-    }
-
-    if (swapXcm) {
-      return [new TransactionError(BasicTxErrorType.INTERNAL_ERROR)];
-    }
-    if (xcmSwap) {
-      return [new TransactionError(BasicTxErrorType.INTERNAL_ERROR)];
-    }
-    if (xcmSwapXcm) {
-      return [new TransactionError(BasicTxErrorType.INTERNAL_ERROR)];
-    }
-    return [new TransactionError(BasicTxErrorType.INTERNAL_ERROR)];
+  validateSwapRequest(request) {
+    throw new Error('Not implemented');
   }
 }
\ No newline at end of file
diff --git a/node_modules/@subwallet/extension-base/utils/account/common.js b/node_modules/@subwallet/extension-base/utils/account/common.js
index e36bd82..f1b01ac 100644
--- a/node_modules/@subwallet/extension-base/utils/account/common.js
+++ b/node_modules/@subwallet/extension-base/utils/account/common.js
@@ -33,6 +33,11 @@ export function reformatAddress(address, networkPrefix = 42, isEthereum = false)
     return encodeAddress(publicKey, networkPrefix, type);
   } catch (e) {
     console.warn('Get error while reformat address', address, e);
+
+    if (!ignoreError) {
+      return '';
+    }
+
     return address;
   }
 }
diff --git a/node_modules/@subwallet/extension-base/utils/index.js b/node_modules/@subwallet/extension-base/utils/index.js
index 6843fc7..f30a11b 100644
--- a/node_modules/@subwallet/extension-base/utils/index.js
+++ b/node_modules/@subwallet/extension-base/utils/index.js
@@ -3,12 +3,13 @@
 
 import { CrowdloanParaState } from '@subwallet/extension-base/background/KoniTypes';
 import { getRandomIpfsGateway, SUBWALLET_IPFS } from '@subwallet/extension-base/koni/api/nft/config';
-import { _isChainCardanoCompatible, _isChainEvmCompatible, _isChainSubstrateCompatible, _isChainTonCompatible } from '@subwallet/extension-base/services/chain-service/utils';
+import { _isChainEvmCompatible, _isPureCardanoChain, _isPureSubstrateChain, _isPureTonChain } from '@subwallet/extension-base/services/chain-service/utils';
 import { reformatAddress } from '@subwallet/extension-base/utils/account';
-import { decodeAddress, encodeAddress, isCardanoAddress, isTonAddress } from '@subwallet/keyring';
+import { decodeAddress, encodeAddress, getKeypairTypeByAddress, isTonAddress } from '@subwallet/keyring';
 import { t } from 'i18next';
 import { assert, BN, hexToU8a, isHex } from '@polkadot/util';
 import { ethereumEncode, isEthereumAddress } from '@polkadot/util-crypto';
+import { CardanoKeypairTypes, EthereumKeypairTypes, SubstrateKeypairTypes, TonKeypairTypes } from "@subwallet/keyring/types";
 export * from "./mv3.js";
 export * from "./fetch.js";
 export * from "./price.js";
@@ -252,10 +253,12 @@ export function isSameAddressType(address1, address2) {
   return isSameEvmAddress || isSameTonAddress || isSameSubstrateAddress;
 }
 export function isAddressAndChainCompatible(address, chain) {
-  const isEvmCompatible = isEthereumAddress(address) && _isChainEvmCompatible(chain);
-  const isTonCompatible = isTonAddress(address) && _isChainTonCompatible(chain);
-  const isSubstrateCompatible = !isEthereumAddress(address) && !isTonAddress(address) && _isChainSubstrateCompatible(chain); // todo: need isSubstrateAddress util function to check exactly
-  const isCardanoCompatible = isCardanoAddress(address) && _isChainCardanoCompatible(chain);
+  const keypairType = getKeypairTypeByAddress(address);
+  const isEvmCompatible = _isChainEvmCompatible(chain) && EthereumKeypairTypes.includes(keypairType); // some chains compatible to substrate and evm, and use evm-address
+  const isTonCompatible = _isPureTonChain(chain) && TonKeypairTypes.includes(keypairType);
+  const isSubstrateCompatible = _isPureSubstrateChain(chain) && SubstrateKeypairTypes.includes(keypairType);
+  const isCardanoCompatible = _isPureCardanoChain(chain) && CardanoKeypairTypes.includes(keypairType);
+
   return isEvmCompatible || isSubstrateCompatible || isTonCompatible || isCardanoCompatible;
 }
 export function getDomainFromUrl(url) {
